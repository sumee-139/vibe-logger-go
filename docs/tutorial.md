# üìö Â∞éÂÖ•„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´

## üèóÔ∏è Step 1: „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó

### 1.1 Âü∫Êú¨ÁöÑ„Å™„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊßãÊàê

```bash
# Êñ∞„Åó„ÅÑGo„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê
mkdir my-project && cd my-project
go mod init my-project

# vibe-logger-go„ÇíËøΩÂä†
go get github.com/sumee-139/vibe-logger-go@v1.0.0
```

### 1.2 Êé®Â•®„Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÈÄ†

```
my-project/
‚îú‚îÄ‚îÄ main.go           # „É°„Ç§„É≥„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥
‚îú‚îÄ‚îÄ go.mod           # Go „É¢„Ç∏„É•„Éº„É´ÂÆöÁæ©
‚îú‚îÄ‚îÄ go.sum           # ‰æùÂ≠òÈñ¢‰øÇ„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„Çµ„É†
‚îú‚îÄ‚îÄ config/          # Ë®≠ÂÆö„Éï„Ç°„Ç§„É´
‚îú‚îÄ‚îÄ logs/            # „É≠„Ç∞„Éá„Ç£„É¨„ÇØ„Éà„É™ÔºàËá™Âãï‰ΩúÊàêÔºâ
‚îÇ   ‚îú‚îÄ‚îÄ default/     # „Éá„Éï„Ç©„É´„Éà„Éó„É≠„Ç∏„Çß„ÇØ„Éà
‚îÇ   ‚îî‚îÄ‚îÄ my-service/  # „Ç´„Çπ„Çø„É†„Éó„É≠„Ç∏„Çß„ÇØ„Éà
‚îî‚îÄ‚îÄ internal/        # ÂÜÖÈÉ®„Éë„ÉÉ„Ç±„Éº„Ç∏
```

## üîß Step 2: Âü∫Êú¨ÁöÑ„Å™‰Ωø„ÅÑÊñπ

### 2.1 ÊúÄÂ∞èÊßãÊàê„Åß„ÅÆÂ∞éÂÖ•

```go
package main

import (
    "fmt"
    "log"
    
    "github.com/sumee-139/vibe-logger-go"
)

func main() {
    // „Éá„Éï„Ç©„É´„ÉàË®≠ÂÆö„Åß„É≠„Ç¨„Éº‰ΩúÊàê
    logger, err := vibelogger.CreateFileLogger("my-service")
    if err != nil {
        log.Fatalf("Failed to create logger: %v", err)
    }
    defer logger.Close()
    
    // Âü∫Êú¨ÁöÑ„Å™„É≠„Ç∞Âá∫Âäõ
    logger.Info("init", "Service initialization started")
    
    // „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞‰æã
    if err := doSomething(); err != nil {
        logger.Error("operation", "Failed to execute operation", 
            vibelogger.WithContext("error", err.Error()))
        return
    }
    
    logger.Info("shutdown", "Service shutdown completed")
}

func doSomething() error {
    // „ÉÄ„Éü„Éº„ÅÆÂá¶ÁêÜ
    return fmt.Errorf("simulated error")
}
```

### 2.2 Web„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Åß„ÅÆ‰ΩøÁî®‰æã

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "time"
    
    "github.com/sumee-139/vibe-logger-go"
)

type App struct {
    logger *vibelogger.Logger
}

func NewApp() (*App, error) {
    // Web„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Áî®Ë®≠ÂÆö
    config := &vibelogger.LoggerConfig{
        ProjectName:     "web-api",
        MaxFileSize:     20 * 1024 * 1024, // 20MB
        RotationEnabled: true,
        MaxRotatedFiles: 5,
        EnableMemoryLog: true,
        MemoryLogLimit:  500, // „Ç®„É©„ÉºÂàÜÊûêÁî®
    }
    
    logger, err := vibelogger.CreateFileLoggerWithConfig("api-server", config)
    if err != nil {
        return nil, fmt.Errorf("failed to create logger: %w", err)
    }
    
    return &App{logger: logger}, nil
}

func (app *App) handleRequest(w http.ResponseWriter, r *http.Request) {
    correlationID := r.Header.Get("X-Correlation-ID")
    if correlationID == "" {
        correlationID = generateCorrelationID()
    }
    
    // „É™„ÇØ„Ç®„Çπ„ÉàÈñãÂßã„É≠„Ç∞
    app.logger.Info("request_start", "Handling HTTP request",
        vibelogger.WithContext("method", r.Method),
        vibelogger.WithContext("path", r.URL.Path),
        vibelogger.WithContext("remote_addr", r.RemoteAddr),
        vibelogger.WithCorrelationID(correlationID))
    
    start := time.Now()
    
    // „Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØÂá¶ÁêÜ
    response := map[string]interface{}{
        "message": "Hello, World!",
        "timestamp": time.Now().UTC(),
    }
    
    // „É¨„Çπ„Éù„É≥„ÇπÈÄÅ‰ø°
    w.Header().Set("Content-Type", "application/json")
    w.Header().Set("X-Correlation-ID", correlationID)
    json.NewEncoder(w).Encode(response)
    
    duration := time.Since(start)
    
    // „É™„ÇØ„Ç®„Çπ„ÉàÂÆå‰∫Ü„É≠„Ç∞
    app.logger.Info("request_complete", "HTTP request completed",
        vibelogger.WithContext("status_code", 200),
        vibelogger.WithContext("duration_ms", duration.Milliseconds()),
        vibelogger.WithCorrelationID(correlationID))
}

func generateCorrelationID() string {
    return fmt.Sprintf("req-%d", time.Now().UnixNano())
}

func main() {
    app, err := NewApp()
    if err != nil {
        log.Fatalf("Failed to initialize app: %v", err)
    }
    defer app.logger.Close()
    
    http.HandleFunc("/", app.handleRequest)
    
    app.logger.Info("server_start", "Starting HTTP server", 
        vibelogger.WithContext("port", 8080))
    
    if err := http.ListenAndServe(":8080", nil); err != nil {
        app.logger.Error("server_error", "HTTP server failed", 
            vibelogger.WithContext("error", err.Error()))
    }
}
```

## ‚öôÔ∏è Step 3: Ë®≠ÂÆö„ÅÆ„Ç´„Çπ„Çø„Éû„Ç§„Ç∫

### 3.1 Áí∞Â¢ÉÂà•Ë®≠ÂÆöÁÆ°ÁêÜ

```go
package config

import (
    "os"
    "strconv"
    
    "github.com/sumee-139/vibe-logger-go"
)

func GetLoggerConfig() (*vibelogger.LoggerConfig, error) {
    env := getEnv("APP_ENV", "development")
    
    switch env {
    case "production":
        return getProductionConfig()
    case "staging":
        return getStagingConfig()
    default:
        return getDevelopmentConfig()
    }
}

func getProductionConfig() (*vibelogger.LoggerConfig, error) {
    return &vibelogger.LoggerConfig{
        ProjectName:     getEnv("APP_NAME", "production-app"),
        MaxFileSize:     getEnvInt64("LOG_MAX_SIZE", 100*1024*1024), // 100MB
        RotationEnabled: true,
        MaxRotatedFiles: getEnvInt("LOG_MAX_FILES", 20),
        EnableMemoryLog: false, // „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÈáçË¶ñ
        Environment:     "production",
    }, nil
}

func getDevelopmentConfig() (*vibelogger.LoggerConfig, error) {
    return &vibelogger.LoggerConfig{
        ProjectName:     getEnv("APP_NAME", "dev-app"),
        MaxFileSize:     getEnvInt64("LOG_MAX_SIZE", 10*1024*1024), // 10MB
        RotationEnabled: true,
        MaxRotatedFiles: 5,
        EnableMemoryLog: true, // „Éá„Éê„ÉÉ„Ç∞Áî®
        MemoryLogLimit:  1000,
        Environment:     "development",
    }, nil
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvInt64(key string, defaultValue int64) int64 {
    if value := os.Getenv(key); value != "" {
        if parsed, err := strconv.ParseInt(value, 10, 64); err == nil {
            return parsed
        }
    }
    return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
    return int(getEnvInt64(key, int64(defaultValue)))
}
```

### 3.2 ÊßãÈÄ†Âåñ„É≠„ÇÆ„É≥„Ç∞„Éë„Çø„Éº„É≥

```go
package logging

import (
    "context"
    "fmt"
    
    "github.com/sumee-139/vibe-logger-go"
)

type StructuredLogger struct {
    logger *vibelogger.Logger
    serviceName string
    version string
}

func NewStructuredLogger(serviceName, version string) (*StructuredLogger, error) {
    config := &vibelogger.LoggerConfig{
        ProjectName: serviceName,
        MaxFileSize: 50 * 1024 * 1024,
        RotationEnabled: true,
        EnableMemoryLog: true,
        MemoryLogLimit: 500,
    }
    
    logger, err := vibelogger.CreateFileLoggerWithConfig(serviceName, config)
    if err != nil {
        return nil, fmt.Errorf("failed to create structured logger: %w", err)
    }
    
    return &StructuredLogger{
        logger: logger,
        serviceName: serviceName,
        version: version,
    }, nil
}

// „Éì„Ç∏„Éç„Çπ„Ç§„Éô„É≥„Éà„É≠„Ç∞
func (sl *StructuredLogger) LogBusinessEvent(ctx context.Context, event string, message string, fields map[string]interface{}) {
    options := []vibelogger.LogOption{
        vibelogger.WithContext("service", sl.serviceName),
        vibelogger.WithContext("version", sl.version),
        vibelogger.WithContext("event_type", "business"),
    }
    
    // „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Åã„ÇâÁõ∏Èñ¢ID„ÇíÂèñÂæó
    if correlationID := getCorrelationIDFromContext(ctx); correlationID != "" {
        options = append(options, vibelogger.WithCorrelationID(correlationID))
    }
    
    // „Ç´„Çπ„Çø„É†„Éï„Ç£„Éº„É´„Éâ„ÇíËøΩÂä†
    for key, value := range fields {
        options = append(options, vibelogger.WithContext(key, value))
    }
    
    sl.logger.Info(event, message, options...)
}

// „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„É≠„Ç∞
func (sl *StructuredLogger) LogPerformance(ctx context.Context, operation string, durationMs int64, fields map[string]interface{}) {
    options := []vibelogger.LogOption{
        vibelogger.WithContext("service", sl.serviceName),
        vibelogger.WithContext("operation", operation),
        vibelogger.WithContext("duration_ms", durationMs),
        vibelogger.WithContext("event_type", "performance"),
    }
    
    if correlationID := getCorrelationIDFromContext(ctx); correlationID != "" {
        options = append(options, vibelogger.WithCorrelationID(correlationID))
    }
    
    for key, value := range fields {
        options = append(options, vibelogger.WithContext(key, value))
    }
    
    if durationMs > 5000 { // 5Áßí‰ª•‰∏ä„ÅØË≠¶Âëä
        sl.logger.Warn(operation+"_slow", fmt.Sprintf("Slow operation detected: %dms", durationMs), options...)
    } else {
        sl.logger.Info(operation+"_perf", fmt.Sprintf("Operation completed in %dms", durationMs), options...)
    }
}

// „Ç®„É©„Éº„É≠„Ç∞Ôºà„Çπ„Çø„ÉÉ„ÇØ„Éà„É¨„Éº„Çπ‰ªò„ÅçÔºâ
func (sl *StructuredLogger) LogError(ctx context.Context, operation string, err error, fields map[string]interface{}) {
    options := []vibelogger.LogOption{
        vibelogger.WithContext("service", sl.serviceName),
        vibelogger.WithContext("error", err.Error()),
        vibelogger.WithContext("event_type", "error"),
    }
    
    if correlationID := getCorrelationIDFromContext(ctx); correlationID != "" {
        options = append(options, vibelogger.WithCorrelationID(correlationID))
    }
    
    for key, value := range fields {
        options = append(options, vibelogger.WithContext(key, value))
    }
    
    sl.logger.Error(operation, fmt.Sprintf("Error occurred: %v", err), options...)
}

func (sl *StructuredLogger) Close() error {
    return sl.logger.Close()
}

func getCorrelationIDFromContext(ctx context.Context) string {
    if id, ok := ctx.Value("correlation_id").(string); ok {
        return id
    }
    return ""
}
```

## üîÑ Step 4: „É≠„Ç∞„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥

### 4.1 Ëá™Âãï„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥Ë®≠ÂÆö

```go
config := &vibelogger.LoggerConfig{
    ProjectName:     "my-app",
    MaxFileSize:     50 * 1024 * 1024, // 50MB „ÅßËá™Âãï„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥
    RotationEnabled: true,
    MaxRotatedFiles: 10, // ÊúÄÂ§ß10ÂÄã„ÅÆÂè§„ÅÑ„Éï„Ç°„Ç§„É´„Çí‰øùÊåÅ
}

logger, err := vibelogger.CreateFileLoggerWithConfig("rotated-service", config)
```

### 4.2 ÊâãÂãï„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥

```go
// ÂêåÊúü„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥ÔºàÂá¶ÁêÜ„Çí„Éñ„É≠„ÉÉ„ÇØÔºâ
if err := logger.ForceRotation(); err != nil {
    log.Printf("Failed to rotate log: %v", err)
}

// ÈùûÂêåÊúü„É≠„Éº„ÉÜ„Éº„Ç∑„Éß„É≥ÔºàÂá¶ÁêÜ„ÇíÁ∂ôÁ∂öÔºâ
logger.ForceRotationAsync()
```

## üß™ Step 5: „ÉÜ„Çπ„Éà„Åß„ÅÆ‰ΩøÁî®

### 5.1 „ÉÜ„Çπ„ÉàÁî®„É°„É¢„É™„É≠„Ç∞

```go
func TestBusinessLogic(t *testing.T) {
    // „ÉÜ„Çπ„ÉàÁî®„É°„É¢„É™„Ç™„É≥„É™„ÉºË®≠ÂÆö
    config := &vibelogger.LoggerConfig{
        AutoSave:        false, // „Éï„Ç°„Ç§„É´Âá∫Âäõ„Å™„Åó
        EnableMemoryLog: true,
        MemoryLogLimit:  100,
    }
    
    logger := vibelogger.NewLoggerWithConfig("test", config)
    
    // „ÉÜ„Çπ„ÉàÂØæË±°„ÅÆÂÆüË°å
    businessLogic(logger)
    
    // „É≠„Ç∞Âá∫Âäõ„ÅÆÊ§úË®º
    logs := logger.GetMemoryLogs()
    assert.Equal(t, 3, len(logs))
    assert.Equal(t, "business_event", logs[0].Operation)
    assert.Equal(t, "INFO", logs[0].Level)
}

func businessLogic(logger *vibelogger.Logger) {
    logger.Info("business_event", "Event occurred")
    logger.Warn("validation", "Validation warning")
    logger.Info("completion", "Process completed")
}
```

## üìã Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó

- [‚öôÔ∏è Ë®≠ÂÆö„É™„Éï„Ç°„É¨„É≥„Çπ](configuration.md) - Ë©≥Á¥∞„Å™Ë®≠ÂÆö„Ç™„Éó„Ç∑„Éß„É≥
- [üîß API„É™„Éï„Ç°„É¨„É≥„Çπ](api-reference.md) - ÂÖ®APIÈñ¢Êï∞„ÅÆË©≥Á¥∞
- [üí° „Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ](best-practices.md) - Êé®Â•®„Éë„Çø„Éº„É≥„Å®„Éé„Ç¶„Éè„Ç¶
- [üîç „Éà„É©„Éñ„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞](troubleshooting.md) - „Çà„Åè„ÅÇ„ÇãÂïèÈ°å„Å®Ëß£Ê±∫ÊñπÊ≥ï